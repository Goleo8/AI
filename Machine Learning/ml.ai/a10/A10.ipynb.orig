{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "_uuid": "90e3a2685594cc6aae3914d3d519be153b050d78"
   },
   "source": [
    "\n",
    "\n",
    "Your task is to beat all benchmarks in this competition. Here you wonâ€™t be provided with detailed instructions. Hopefully, at this stage of the course, it's enough for you to take a quick look at the data in order to understand that this is the type of task where gradient boosting will do. Most likely it will be LightGBM. But you can try Xgboost or Catboost as well.\n",
    "\n",
    "<img src=\"https://habrastorage.org/webt/fs/42/ms/fs42ms0r7qsoj-da4x7yfntwrbq.jpeg\" width=30% />"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {
    "_uuid": "b486c4beb6f64fbeb70610a0e5ed7145256605e1",
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.pipeline import Pipeline\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from sklearn.metrics import roc_auc_score\n",
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "_uuid": "2e7833f60e9392ba0526aec5b68ea8587ce90274",
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "train_df = pd.read_csv('../../datasets/flight/flight_delays_train.csv')\n",
    "test_df = pd.read_csv('../../datasets/flight/flight_delays_test.csv')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "_uuid": "c02aa9ea53a2733cd5683bd10beed2b561acf7bb",
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Month</th>\n",
       "      <th>DayofMonth</th>\n",
       "      <th>DayOfWeek</th>\n",
       "      <th>DepTime</th>\n",
       "      <th>UniqueCarrier</th>\n",
       "      <th>Origin</th>\n",
       "      <th>Dest</th>\n",
       "      <th>Distance</th>\n",
       "      <th>dep_delayed_15min</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>c-8</td>\n",
       "      <td>c-21</td>\n",
       "      <td>c-7</td>\n",
       "      <td>1934</td>\n",
       "      <td>AA</td>\n",
       "      <td>ATL</td>\n",
       "      <td>DFW</td>\n",
       "      <td>732</td>\n",
       "      <td>N</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>c-4</td>\n",
       "      <td>c-20</td>\n",
       "      <td>c-3</td>\n",
       "      <td>1548</td>\n",
       "      <td>US</td>\n",
       "      <td>PIT</td>\n",
       "      <td>MCO</td>\n",
       "      <td>834</td>\n",
       "      <td>N</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>c-9</td>\n",
       "      <td>c-2</td>\n",
       "      <td>c-5</td>\n",
       "      <td>1422</td>\n",
       "      <td>XE</td>\n",
       "      <td>RDU</td>\n",
       "      <td>CLE</td>\n",
       "      <td>416</td>\n",
       "      <td>N</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>c-11</td>\n",
       "      <td>c-25</td>\n",
       "      <td>c-6</td>\n",
       "      <td>1015</td>\n",
       "      <td>OO</td>\n",
       "      <td>DEN</td>\n",
       "      <td>MEM</td>\n",
       "      <td>872</td>\n",
       "      <td>N</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>c-10</td>\n",
       "      <td>c-7</td>\n",
       "      <td>c-6</td>\n",
       "      <td>1828</td>\n",
       "      <td>WN</td>\n",
       "      <td>MDW</td>\n",
       "      <td>OMA</td>\n",
       "      <td>423</td>\n",
       "      <td>Y</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "  Month DayofMonth DayOfWeek  DepTime UniqueCarrier Origin Dest  Distance  \\\n",
       "0   c-8       c-21       c-7     1934            AA    ATL  DFW       732   \n",
       "1   c-4       c-20       c-3     1548            US    PIT  MCO       834   \n",
       "2   c-9        c-2       c-5     1422            XE    RDU  CLE       416   \n",
       "3  c-11       c-25       c-6     1015            OO    DEN  MEM       872   \n",
       "4  c-10        c-7       c-6     1828            WN    MDW  OMA       423   \n",
       "\n",
       "  dep_delayed_15min  \n",
       "0                 N  \n",
       "1                 N  \n",
       "2                 N  \n",
       "3                 N  \n",
       "4                 Y  "
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train_df.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "_uuid": "4a0f1e18cc9b10cfd4f098183511f21722e61752",
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Month</th>\n",
       "      <th>DayofMonth</th>\n",
       "      <th>DayOfWeek</th>\n",
       "      <th>DepTime</th>\n",
       "      <th>UniqueCarrier</th>\n",
       "      <th>Origin</th>\n",
       "      <th>Dest</th>\n",
       "      <th>Distance</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>c-7</td>\n",
       "      <td>c-25</td>\n",
       "      <td>c-3</td>\n",
       "      <td>615</td>\n",
       "      <td>YV</td>\n",
       "      <td>MRY</td>\n",
       "      <td>PHX</td>\n",
       "      <td>598</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>c-4</td>\n",
       "      <td>c-17</td>\n",
       "      <td>c-2</td>\n",
       "      <td>739</td>\n",
       "      <td>WN</td>\n",
       "      <td>LAS</td>\n",
       "      <td>HOU</td>\n",
       "      <td>1235</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>c-12</td>\n",
       "      <td>c-2</td>\n",
       "      <td>c-7</td>\n",
       "      <td>651</td>\n",
       "      <td>MQ</td>\n",
       "      <td>GSP</td>\n",
       "      <td>ORD</td>\n",
       "      <td>577</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>c-3</td>\n",
       "      <td>c-25</td>\n",
       "      <td>c-7</td>\n",
       "      <td>1614</td>\n",
       "      <td>WN</td>\n",
       "      <td>BWI</td>\n",
       "      <td>MHT</td>\n",
       "      <td>377</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>c-6</td>\n",
       "      <td>c-6</td>\n",
       "      <td>c-3</td>\n",
       "      <td>1505</td>\n",
       "      <td>UA</td>\n",
       "      <td>ORD</td>\n",
       "      <td>STL</td>\n",
       "      <td>258</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "  Month DayofMonth DayOfWeek  DepTime UniqueCarrier Origin Dest  Distance\n",
       "0   c-7       c-25       c-3      615            YV    MRY  PHX       598\n",
       "1   c-4       c-17       c-2      739            WN    LAS  HOU      1235\n",
       "2  c-12        c-2       c-7      651            MQ    GSP  ORD       577\n",
       "3   c-3       c-25       c-7     1614            WN    BWI  MHT       377\n",
       "4   c-6        c-6       c-3     1505            UA    ORD  STL       258"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "test_df.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "_uuid": "ce71f38fec3d94108609ef0cae861010ab0e8ca6"
   },
   "source": [
    "Given flight departure time, carrier's code, departure airport, destination location, and flight distance, you have to predict departure delay for more than 15 minutes. As the simplest benchmark, let's take logistic regression and two features that are easiest to take: DepTime and Distance. This will correspond to **\"simple logit baseline\"** on Public LB."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "num_cols = ['Distance','DepTime']\n",
    "X_train_num=train_df[num_cols].values\n",
    "y_train_num=train_df['dep_delayed_15min'].map({'N':0,'Y':1}).values\n",
    "X_test_num=test_df[['Distance', 'DepTime']].values\n",
    "\n",
    "X_train_part_num, X_valid_num, y_train_part_num, y_valid_num = \\\n",
    "    train_test_split(X_train_num, y_train_num, \n",
    "                     test_size=0.3, random_state=17)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
<<<<<<< HEAD
    "_uuid": "4d27fbb1636578833b32628ab40c77b6cb13564e",
    "collapsed": false
=======
    "_uuid": "309be359915c00cbad41384a08926ddf25d47c7b"
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.6795691465352607"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "logit_pipe = Pipeline([('scaler', StandardScaler()),\n",
    "                       ('logit', LogisticRegression(C=1, random_state=17, solver='liblinear'))])\n",
    "\n",
    "logit_pipe.fit(X_train_part_num, y_train_part_num)\n",
    "logit_valid_num_pred = logit_pipe.predict_proba(X_valid_num)[:, 1]\n",
    "\n",
    "roc_auc_score(y_valid_num, logit_valid_num_pred)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
<<<<<<< HEAD
    "_uuid": "ed9e095279f1033f927b3750567051268d05987d",
    "collapsed": true
=======
    "_uuid": "082bfede543f62192c55146294cdb23b3b898c90"
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   },
   "outputs": [],
   "source": [
    "logit_pipe.fit(X_train_num, y_train_num)\n",
    "logit_test_pred = logit_pipe.predict_proba(X_test_num)[:, 1]\n",
    "\n",
    "pd.Series(logit_test_pred, \n",
    "          name='dep_delayed_15min').to_csv('logit_2feat_basic.csv', \n",
    "                                           index_label='id', header=True)"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 117,
   "metadata": {
    "_uuid": "5bac98797b2bfb23851d735ec3761fc0e1401e61",
    "collapsed": true
   },
=======
   "execution_count": 32,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [],
   "source": [
    "from sklearn.preprocessing import OneHotEncoder\n",
    "\n",
    "cat_cols = [ i for i in train_df.columns if i not in ['Distance','DepTime','dep_delayed_15min']]\n",
    "df = pd.concat([train_df[cat_cols],test_df[cat_cols]],axis = 0)\n",
    "\n",
    "onehot=OneHotEncoder()\n",
    "onehot.fit(df)\n",
    "X_train_onehot = onehot.transform(train_df[cat_cols])\n",
    "\n",
    "scaler = StandardScaler()\n",
    "X_train_num_norm=scaler.fit_transform(X_train_num)\n",
    "X_test_num_norm=scaler.transform(X_test_num)\n",
    "\n",
<<<<<<< HEAD
    "# X_train_part, X_valid, y_train_part, y_valid = \\\n",
    "#     train_test_split(X_train, y_train, \n",
    "#                      test_size=0.3, random_state=17)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "_uuid": "11a40f5b7c0403853ce36618d97683bec6faff12",
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "logit_pipe = Pipeline([('scaler', StandardScaler()),\n",
    "                       ('logit', LogisticRegression(C=1, random_state=17, solver='liblinear'))])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "_uuid": "309be359915c00cbad41384a08926ddf25d47c7b",
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.6991062491760075"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "logit_pipe.fit(X_train_part, y_train_part)\n",
    "logit_valid_pred = logit_pipe.predict_proba(X_valid)[:, 1]\n",
=======
    "X_train, y_train = np.hstack([X_train_onehot.toarray(),X_train_num_norm]), train_df['dep_delayed_15min'].map({'Y': 1, 'N': 0}).values\n",
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
    "\n",
    "X_test_onehot = onehot.transform(test_df[cat_cols])\n",
    "X_test = np.hstack([X_test_onehot.toarray(),X_test_num_norm])\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "X_train_part, X_valid, y_train_part, y_valid = \\\n",
    "    train_test_split(X_train, y_train, \n",
    "                     test_size=0.3, random_state=17)"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 35,
   "metadata": {
    "collapsed": true
   },
=======
   "execution_count": 21,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [],
   "source": [
    "from sklearn.ensemble import RandomForestClassifier"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 36,
   "metadata": {
    "collapsed": true
   },
=======
   "execution_count": 22,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [],
   "source": [
    "rf_clf = RandomForestClassifier(n_estimators=1000,verbose=1,oob_score=True,n_jobs=-1)"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 37,
   "metadata": {
    "collapsed": false
   },
=======
   "execution_count": 23,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[Parallel(n_jobs=-1)]: Using backend ThreadingBackend with 4 concurrent workers.\n",
      "[Parallel(n_jobs=-1)]: Done  42 tasks      | elapsed:   28.3s\n",
      "[Parallel(n_jobs=-1)]: Done 192 tasks      | elapsed:  2.1min\n",
      "[Parallel(n_jobs=-1)]: Done 442 tasks      | elapsed:  4.9min\n",
      "[Parallel(n_jobs=-1)]: Done 792 tasks      | elapsed:  8.8min\n",
      "[Parallel(n_jobs=-1)]: Done 1000 out of 1000 | elapsed: 11.2min finished\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "RandomForestClassifier(bootstrap=True, class_weight=None, criterion='gini',\n",
       "            max_depth=None, max_features='auto', max_leaf_nodes=None,\n",
       "            min_impurity_decrease=0.0, min_impurity_split=None,\n",
       "            min_samples_leaf=1, min_samples_split=2,\n",
       "            min_weight_fraction_leaf=0.0, n_estimators=1000, n_jobs=-1,\n",
       "            oob_score=True, random_state=None, verbose=1, warm_start=False)"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "rf_clf.fit(X_train_part,y_train_part)"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 109,
   "metadata": {
    "collapsed": false
   },
=======
   "execution_count": 24,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.8170285714285714"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "rf_clf.oob_score_"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 110,
   "metadata": {
    "collapsed": false
   },
=======
   "execution_count": 25,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[Parallel(n_jobs=4)]: Using backend ThreadingBackend with 4 concurrent workers.\n",
      "[Parallel(n_jobs=4)]: Done  42 tasks      | elapsed:    0.7s\n",
      "[Parallel(n_jobs=4)]: Done 192 tasks      | elapsed:    2.8s\n",
      "[Parallel(n_jobs=4)]: Done 442 tasks      | elapsed:    6.2s\n",
      "[Parallel(n_jobs=4)]: Done 792 tasks      | elapsed:   11.5s\n",
      "[Parallel(n_jobs=4)]: Done 1000 out of 1000 | elapsed:   15.1s finished\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "0.7338332168787723"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "rf_valid_pred = rf_clf.predict_proba(X_valid)[:, 1]\n",
    "\n",
    "roc_auc_score(y_valid, rf_valid_pred)"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 122,
   "metadata": {
    "collapsed": false
   },
=======
   "execution_count": 33,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[Parallel(n_jobs=4)]: Using backend ThreadingBackend with 4 concurrent workers.\n",
      "[Parallel(n_jobs=4)]: Done  42 tasks      | elapsed:    1.9s\n",
      "[Parallel(n_jobs=4)]: Done 192 tasks      | elapsed:    7.7s\n",
      "[Parallel(n_jobs=4)]: Done 442 tasks      | elapsed:   17.3s\n",
      "[Parallel(n_jobs=4)]: Done 792 tasks      | elapsed:   35.4s\n",
      "[Parallel(n_jobs=4)]: Done 1000 out of 1000 | elapsed:   49.3s finished\n"
     ]
    }
   ],
   "source": [
    "# rf_clf.fit(X_train, y_train)\n",
    "rf_test_pred = rf_clf.predict_proba(X_test)[:, 1]\n",
    "\n",
    "pd.Series(rf_test_pred, \n",
    "          name='dep_delayed_15min').to_csv('rf_2feat_basic.csv', \n",
    "                                           index_label='id', header=True)"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 111,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from sklearn.decomposition import PCA"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 112,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "pca = PCA(n_components=0.9)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 118,
   "metadata": {
    "collapsed": true
   },
=======
   "execution_count": 35,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [],
   "source": [
    "length = len(rf_clf.feature_importances_)\n",
    "index = range(length)\n",
    "important_features=sorted(zip(index,rf_clf.feature_importances_),key=lambda x:x[1],reverse=True)[:200]\n",
    "feature_index = list(map(lambda x:x[0],important_features))\n",
    "X_train_part_imp=X_train_part[:,feature_index]\n",
    "X_valid_imp=X_valid[:,feature_index]\n",
    "X_test_imp=X_test[:,feature_index]"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 119,
   "metadata": {
    "collapsed": false
   },
=======
   "execution_count": 36,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[Parallel(n_jobs=-1)]: Using backend ThreadingBackend with 4 concurrent workers.\n",
      "[Parallel(n_jobs=-1)]: Done  42 tasks      | elapsed:    7.4s\n",
      "[Parallel(n_jobs=-1)]: Done 192 tasks      | elapsed:   37.1s\n",
      "[Parallel(n_jobs=-1)]: Done 442 tasks      | elapsed:  1.6min\n",
      "[Parallel(n_jobs=-1)]: Done 792 tasks      | elapsed:  2.6min\n",
      "[Parallel(n_jobs=-1)]: Done 1000 out of 1000 | elapsed:  3.2min finished\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "RandomForestClassifier(bootstrap=True, class_weight=None, criterion='gini',\n",
       "            max_depth=None, max_features='auto', max_leaf_nodes=None,\n",
       "            min_impurity_decrease=0.0, min_impurity_split=None,\n",
       "            min_samples_leaf=1, min_samples_split=2,\n",
       "            min_weight_fraction_leaf=0.0, n_estimators=1000, n_jobs=-1,\n",
       "            oob_score=True, random_state=None, verbose=1, warm_start=False)"
      ]
     },
     "execution_count": 36,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "rf_clf_imp = RandomForestClassifier(n_estimators=1000,verbose=1,oob_score=True,n_jobs=-1)\n",
    "rf_clf_imp.fit(X_train_part_imp,y_train_part)"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 120,
   "metadata": {
    "collapsed": true,
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "X_train_part_pca, X_valid_pca, y_train_part_pca, y_valid_pca = \\\n",
    "    train_test_split(X_train_pca, y_train, \n",
    "                     test_size=0.3, random_state=17)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 121,
   "metadata": {
    "collapsed": false
   },
=======
   "execution_count": 38,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.8197285714285715\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[Parallel(n_jobs=4)]: Using backend ThreadingBackend with 4 concurrent workers.\n",
      "[Parallel(n_jobs=4)]: Done  42 tasks      | elapsed:    0.5s\n",
      "[Parallel(n_jobs=4)]: Done 192 tasks      | elapsed:    3.0s\n",
      "[Parallel(n_jobs=4)]: Done 442 tasks      | elapsed:    7.3s\n",
      "[Parallel(n_jobs=4)]: Done 792 tasks      | elapsed:   11.5s\n",
      "[Parallel(n_jobs=4)]: Done 1000 out of 1000 | elapsed:   14.2s finished\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "0.7365117455290426"
      ]
     },
     "execution_count": 38,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print(rf_clf_imp.oob_score_)\n",
    "rf_valid_pred_imp = rf_clf_imp.predict_proba(X_valid_imp)[:, 1]\n",
    "\n",
    "roc_auc_score(y_valid, rf_valid_pred_imp)"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 124,
   "metadata": {
    "collapsed": false
   },
=======
   "execution_count": 39,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[Parallel(n_jobs=-1)]: Using backend ThreadingBackend with 4 concurrent workers.\n",
      "[Parallel(n_jobs=-1)]: Done  42 tasks      | elapsed:   14.2s\n",
      "[Parallel(n_jobs=-1)]: Done 192 tasks      | elapsed:  1.1min\n",
      "[Parallel(n_jobs=-1)]: Done 442 tasks      | elapsed:  2.5min\n",
      "[Parallel(n_jobs=-1)]: Done 792 tasks      | elapsed:  4.5min\n",
      "[Parallel(n_jobs=-1)]: Done 1000 out of 1000 | elapsed:  5.6min finished\n",
      "[Parallel(n_jobs=4)]: Using backend ThreadingBackend with 4 concurrent workers.\n",
      "[Parallel(n_jobs=4)]: Done  42 tasks      | elapsed:    1.7s\n",
      "[Parallel(n_jobs=4)]: Done 192 tasks      | elapsed:    6.2s\n",
      "[Parallel(n_jobs=4)]: Done 442 tasks      | elapsed:   15.4s\n",
      "[Parallel(n_jobs=4)]: Done 792 tasks      | elapsed:   26.1s\n",
      "[Parallel(n_jobs=4)]: Done 1000 out of 1000 | elapsed:   32.2s finished\n"
     ]
    }
   ],
   "source": [
    "rf_clf_imp.fit(X_train[:,feature_index],y_train)\n",
    "y_test_pred_imp = rf_clf_imp.predict_proba(X_test_imp)[:, 1]\n",
    "\n",
    "pd.Series(y_test_pred_imp, \n",
    "          name='dep_delayed_15min').to_csv('rf_2feat_imp.csv', \n",
    "                                           index_label='id', header=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [],
   "source": [
    "import xgboost as xgb"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
=======
   "execution_count": 43,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [],
   "source": [
    "xgb_clf = xgb.XGBClassifier(n_estimators=1000,learning_rate=0.1)"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 40,
   "metadata": {
    "collapsed": false
   },
=======
   "execution_count": 44,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [
    {
     "data": {
      "text/plain": [
       "XGBClassifier(base_score=0.5, booster='gbtree', colsample_bylevel=1,\n",
       "       colsample_bytree=1, gamma=0, learning_rate=0.1, max_delta_step=0,\n",
       "       max_depth=3, min_child_weight=1, missing=None, n_estimators=1000,\n",
       "       n_jobs=1, nthread=None, objective='binary:logistic', random_state=0,\n",
       "       reg_alpha=0, reg_lambda=1, scale_pos_weight=1, seed=None,\n",
       "       silent=True, subsample=1)"
      ]
     },
     "execution_count": 44,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "xgb_clf.fit(X_train_part_imp,y_train_part)"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 43,
   "metadata": {
    "collapsed": false
   },
=======
   "execution_count": 46,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<bound method ClassifierMixin.score of XGBClassifier(base_score=0.5, booster='gbtree', colsample_bylevel=1,\n",
      "       colsample_bytree=1, gamma=0, learning_rate=0.1, max_delta_step=0,\n",
      "       max_depth=3, min_child_weight=1, missing=None, n_estimators=1000,\n",
      "       n_jobs=1, nthread=None, objective='binary:logistic', random_state=0,\n",
      "       reg_alpha=0, reg_lambda=1, scale_pos_weight=1, seed=None,\n",
      "       silent=True, subsample=1)>\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "0.7382404401928001"
      ]
     },
     "execution_count": 46,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print(xgb_clf.score)\n",
    "xgb_valid_pred_imp = xgb_clf.predict_proba(X_valid_imp)[:, 1]\n",
    "\n",
    "roc_auc_score(y_valid, xgb_valid_pred_imp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [],
   "source": [
    "xgb_clf.fit(X_train[:,feature_index],y_train)\n",
    "xgb_test_pred_imp = xgb_clf.predict_proba(X_test_imp)[:, 1]\n",
    "\n",
    "pd.Series(xgb_test_pred_imp, \n",
    "          name='dep_delayed_15min').to_csv('xgb_2feat_imp.csv', \n",
    "                                           index_label='id', header=True)"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 42,
   "metadata": {
    "collapsed": false
   },
=======
   "execution_count": 62,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn import metrics\n",
    "def modelfit(alg, X, y,useTrainCV=True, cv_folds=5, early_stopping_rounds=50):\n",
    "    \n",
    "    if useTrainCV:\n",
    "        xgb_param = alg.get_xgb_params()\n",
    "        xgtrain = xgb.DMatrix(X, label=y)\n",
    "        cvresult = xgb.cv(xgb_param, xgtrain, num_boost_round=alg.get_params()['n_estimators'], nfold=cv_folds,\n",
    "            metrics='auc', early_stopping_rounds=early_stopping_rounds)\n",
    "        alg.set_params(n_estimators=cvresult.shape[0])\n",
    "    \n",
    "    #Fit the algorithm on the data\n",
    "    alg.fit(X, y,eval_metric='auc')\n",
    "        \n",
    "    #Predict training set:\n",
    "    dtrain_predictions = alg.predict(X)\n",
    "    dtrain_predprob = alg.predict_proba(X)[:,1]\n",
    "        \n",
    "    #Print model report:\n",
    "    print(\"\\nModel Report\")\n",
    "    print(\"\\nNumber of estimator:%d\"%alg.n_estimators)\n",
    "    print(\"Accuracy : %.4g\" % metrics.accuracy_score(y, dtrain_predictions))\n",
    "    print(\"AUC Score (Train): %f\" % metrics.roc_auc_score(y, dtrain_predprob))\n",
    "                    \n",
    "    feat_imp = pd.Series(alg.feature_importances_).sort_values(ascending=False)\n",
    "    feat_imp.plot(kind='bar', title='Feature Importances')\n",
    "    plt.ylabel('Feature Importance Score')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Model Report\n",
      "\n",
      "Number of estimator:429\n",
      "Accuracy : 0.8366\n",
      "AUC Score (Train): 0.828399\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "xgb1 = xgb.XGBClassifier(\n",
    " learning_rate =0.1,\n",
    " n_estimators=2000,\n",
    " max_depth=5,\n",
    " min_child_weight=1,\n",
    " gamma=0,\n",
    " subsample=0.8,\n",
    " colsample_bytree=0.8,\n",
    " objective= 'binary:logistic',\n",
    " nthread=4,\n",
    " scale_pos_weight=1,\n",
    " seed=27)\n",
    "modelfit(xgb1, X_train_part_imp, y_train_part)"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
=======
   "execution_count": 67,
   "metadata": {},
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fitting 5 folds for each of 12 candidates, totalling 60 fits\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[Parallel(n_jobs=-1)]: Using backend LokyBackend with 4 concurrent workers.\n",
      "[Parallel(n_jobs=-1)]: Done  42 tasks      | elapsed: 41.8min\n",
      "[Parallel(n_jobs=-1)]: Done  60 out of  60 | elapsed: 67.5min finished\n"
     ]
<<<<<<< HEAD
    }
   ],
   "source": [
    "rf_clf_pca = RandomForestClassifier(max_depth=14,verbose=1,oob_score=True,n_jobs=-1)\n",
    "param={'n_estimators':range(100,1000,50)}\n",
    "\n",
    "gs2=GridSearchCV(rf_clf_pca,param_grid=param,cv=5,n_jobs=-1,scoring='roc_auc',verbose=1)\n",
    "gs2.fit(X_train_part_pca,y_train_part_pca)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
=======
    },
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
    {
     "data": {
      "text/plain": [
       "GridSearchCV(cv=5, error_score='raise-deprecating',\n",
       "       estimator=XGBClassifier(base_score=0.5, booster='gbtree', colsample_bylevel=1,\n",
       "       colsample_bytree=0.8, gamma=0, learning_rate=0.1, max_delta_step=0,\n",
       "       max_depth=5, min_child_weight=1, missing=None, n_estimators=429,\n",
       "       n_jobs=1, nthread=4, objective='binary:logistic', random_state=0,\n",
       "       reg_alpha=0, reg_lambda=1, scale_pos_weight=1, seed=27, silent=True,\n",
       "       subsample=0.8),\n",
       "       fit_params=None, iid='warn', n_jobs=-1,\n",
       "       param_grid={'max_depth': range(3, 10, 2), 'min_child_weight': range(1, 6, 2)},\n",
       "       pre_dispatch='2*n_jobs', refit=True, return_train_score='warn',\n",
       "       scoring='roc_auc', verbose=1)"
      ]
     },
     "execution_count": 67,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
<<<<<<< HEAD
    "print(X_train_onehot.shape)\n",
    "print(X_train_part_pca.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from sklearn.datasets import load_boston\n",
    "data=load_boston()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "X,y=data['data'],data['target']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=.3,random_state=42)"
=======
    "from sklearn.model_selection import GridSearchCV\n",
    "param1={'max_depth':range(3,10,2),'min_child_weight':range(1,6,2)}\n",
    "xgb2 = xgb.XGBClassifier(\n",
    " learning_rate =0.1,\n",
    " n_estimators=429,\n",
    " max_depth=5,\n",
    " min_child_weight=1,\n",
    " gamma=0,\n",
    " subsample=0.8,\n",
    " colsample_bytree=0.8,\n",
    " objective= 'binary:logistic',\n",
    " nthread=4,\n",
    " scale_pos_weight=1,\n",
    " seed=27)\n",
    "gSearch1=GridSearchCV(xgb2,param_grid=param1,cv=5,scoring='roc_auc',n_jobs=-1,verbose=1)\n",
    "gSearch1.fit(X_train_part_imp, y_train_part)"
>>>>>>> b7ada0b1c84e674adf92e3d439dfbd0892d85c6b
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "_uuid": "efd64f65bd3ac9d7fd279513a8cf49e7f2cb7ac0"
   },
   "source": [
    "Now you have to beat **\"A10 benchmark\"** on Public LB. It's not challenging at all. Go for LightGBM, maybe some other models (or ensembling) as well. Include categorical features, do some simple feature engineering as well. Good luck!"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "_uuid": "3b8183ed1ffe780333144a4781e1aba663f50473"
   },
   "source": [
    "If you think this course is worth spreading, you can do a favour:\n",
    "* upvote this [announcement](https://www.kaggle.com/general/68205) on Kaggle Forum; optionally, tell your story threin\n",
    "* upvote the mlcourse.ai [Kaggle Dataset](https://www.kaggle.com/kashnitsky/mlcourse), it'll pull the Dataset up in the list of all datasets\n",
    "* upvoting course [Kernels](https://www.kaggle.com/kashnitsky/mlcourse/kernels?sortBy=voteCount&group=everyone&pageSize=20&datasetId=32132) is also a nice thing to do \n",
    "* spread a word on [mlcourse.ai](https://mlcourse.ai) in social networks, the next session is planned to launch in February 2019"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
